//! Retained scene tree example.
//!
//! This example is originally from `i-cant-believe-its-not-bsn`.
use bevy::color::palettes::*;
use bevy::prelude::*;

use bevy_bsn::{Scene, *};

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(scene_tree_plugin)
        .run();
}

/// Plugin for the editor scene tree pane.
fn scene_tree_plugin(app: &mut App) {
    app.add_systems(Startup, mock_setup_pane);
    app.add_systems(Update, build_scene_tree);
}

const DEFAULT_BACKGROUND: Srgba = tailwind::NEUTRAL_600;
const SELECTED_BACKGROUND: Srgba = tailwind::NEUTRAL_700;
const HOVERED_BACKGROUND: Srgba = tailwind::NEUTRAL_500;

// Mock an editor pane.
fn mock_setup_pane(mut commands: Commands) {
    commands.insert_resource(Selection { entity: None });

    commands.spawn((Name::new("Camera"), Camera2d, Hover { count: 0 }));
    commands.spawn((Name::new("Example Entity"), Hover { count: 0 }));

    commands.spawn_empty().retain_scene(bsn! {
        // A full-screen node which centers it's content
        Node {
            width: Val::Percent(100.0),
            height: Val::Percent(100.0),
            align_items: AlignItems::Center,
            justify_content: JustifyContent::Center,
        } [
            // The actual window we will use as the root of the scene tree
            (
                SceneTreeRoot,
                Node {
                    flex_direction: FlexDirection::Column,
                    column_gap: Val::Px(2.0),
                    padding: UiRect::all(Val::Px(8.0)),
                },
                BackgroundColor(DEFAULT_BACKGROUND),
            ),
        ]
    });

    // Add observers to drive input interaction.
    commands.add_observer(select_row);
    commands.add_observer(hover_over_row);
    commands.add_observer(hover_leave_row);
}

// Build the scene tree row template.
fn build_scene_tree(
    mut commands: Commands,
    scene_tree: Single<Entity, With<SceneTreeRoot>>,
    query: Query<(Entity, &Name, Option<&Hover>)>,
    selection: Res<Selection>,
) {
    let rows: Vec<_> = query
        .iter()
        .map(|(entity, name, hover)| scene_tree_row(entity, name, hover, &selection))
        .collect();

    commands.entity(*scene_tree).retain_child_scenes(rows);
}

// Generate scene tree template.
fn scene_tree_row(
    target_entity: Entity,
    target_name: &str,
    hover: Option<&Hover>,
    selection: &Selection,
) -> impl Scene {
    let is_hovered = hover.map(|h| h.count).unwrap_or(0) > 0;
    let is_selected = selection.entity == Some(target_entity);

    let name = target_name.to_string();

    bsn! {
        {target_name}: (
            SceneTreeRow(target_entity),
            Node {
                padding: UiRect::all(Val::Px(4.0)),
                align_items: AlignItems::Center,
            },
            {BorderRadius::all(Val::Px(4.0))},
            BackgroundColor(
                if is_selected { SELECTED_BACKGROUND.into() } else if is_hovered { HOVERED_BACKGROUND.into() } else { Color::NONE }
            )
        ) [
            (Text(name), TextFont { font_size: 11.0 }, {Pickable::IGNORE})
        ]
    }
}

/// Root UI node of the scene tree.
#[derive(Component, Default, Clone)]
struct SceneTreeRoot;

/// A scene tree row UI node.
///
/// Contains the row's corresponding scene entity.
#[derive(Component, Clone)]
struct SceneTreeRow(Entity);

impl Default for SceneTreeRow {
    fn default() -> Self {
        Self(Entity::PLACEHOLDER)
    }
}

/// The selected entity
#[derive(Resource)]
struct Selection {
    entity: Option<Entity>,
}

// Mark selection of scene tree rows.
fn select_row(
    trigger: Trigger<Pointer<Released>>,
    rows: Query<&SceneTreeRow>,
    mut selection: ResMut<Selection>,
) {
    if let Ok(SceneTreeRow(target_entity)) = rows.get(trigger.target) {
        selection.entity = Some(*target_entity);
    }
}

/// The selected entity
#[derive(Component)]
struct Hover {
    count: usize,
}

// Notice how the template pattern encourages you to seperate state and
// presentation. Components used for presentation (those generated by
// `Template`) are overwritten every frame, so we have to store the state else
// where in the ecs. Template state does not have to be derived, but it's often
// easier if it is.
//
// In this case, we store 'hover' information not on the rows themselves but on
// the entities they represent. This would let us centralize hover logic if we
// had other ways to hover entities than the list, for example if they had
// meshes. But I havn't bothered to implement that.

// Track hover
fn hover_over_row(
    trigger: Trigger<Pointer<Over>>,
    rows: Query<&SceneTreeRow>,
    mut hovers: Query<&mut Hover>,
) {
    if let Ok(SceneTreeRow(target_entity)) = rows.get(trigger.target) {
        if let Ok(mut hover) = hovers.get_mut(*target_entity) {
            hover.count += 1;
        }
    }
}

// Track hover
fn hover_leave_row(
    trigger: Trigger<Pointer<Out>>,
    rows: Query<&SceneTreeRow>,
    mut hovers: Query<&mut Hover>,
) {
    if let Ok(SceneTreeRow(target_entity)) = rows.get(trigger.target) {
        if let Ok(mut hover) = hovers.get_mut(*target_entity) {
            hover.count -= 1;
        }
    }
}
